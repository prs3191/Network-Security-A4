#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<pthread.h>
#include<arpa/inet.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<iostream>
#include<stdlib.h>
#include<sstream>
#include <sys/wait.h>
#include <netdb.h>
#include <errno.h>
#include <signal.h>
#include <netinet/in.h>
#include<openssl/des.h>
#include<openssl/rand.h>
#include<fstream>
#include<vector>
#include<openssl/sha.h>
#include<sstream>
#include<cstdlib>
#include<algorithm>

#define BUFSIZE 512
#define SOCBUFSIZE 8000
using namespace std;

static int idx=0;
static vector<char> globinp;

//parser
string tokenizer(vector<char> input, char * delimiter){

//cout<<"\ninput:";
//for (std::vector<char>::const_iterator i = input.begin(); i != input.end(); ++i)
//    std::cout << *i;

int delimcount=0;
string temp="";
//cout<<"\ngbinp sz:"<<globinp.size();
if(globinp.empty()){
//cout<<"\nin parsing..assign global string..";
//globinp=input;
 globinp.swap(input);
//for (std::vector<char>::const_iterator i = globinp.begin(); i != globinp.end(); ++i)
//    std::cout << *i;
}
for(;idx<globinp.size();idx++){
if(globinp[idx]=='/'){
for(;idx<globinp.size() && delimcount<5;){			//skip the delimiter
   if(globinp[idx]=='/'){
    delimcount++;
    idx++;
   }
   else break;
}
}
if(delimcount<5){
  if(delimcount>0){
    idx=idx-delimcount;
    for(;delimcount>0;delimcount--){				//if delimiter is not found, rewind
       temp.push_back(globinp[idx]);
       idx++;
    }
    idx--;
  }
  else{
    temp.push_back(globinp[idx]);
    //cout<<"\ntemp:"<<temp;
  }
}
else{
//idx--;
return temp;
}
}
if(idx==globinp.size()){
idx=0;
globinp.clear();
return temp;
}
}

char RandomNumber () { 					//generate random data of 50kB to be transferred
int n=std::rand()%26; 
char c=(char)(n+65);
//cout<<c;
return c;
}

//read the contents from file
string getkey(string filename){
std::ifstream file(filename.c_str());
std::string str;
std::string file_contents;
while (std::getline(file, str))
{
  file_contents += str;
  if(!file.eof())
     file_contents.push_back('\n');
} 
file.close(); 
return file_contents;
}

//decrypt using the private key generated from public key,private key pair
string de_crypt(string str){

std::ofstream file;
file.open("encrypted_ra.enc");
file << str;
file.close();
char c[8000];
strcpy(c,"openssl rsautl -decrypt -inkey serkey.pem -in r_a.enc -out recv_ra.txt"); //decrypt by Bob private key
system(c);

//cout<<"\n Decrypted str using Bob's private key";
string dec=getkey("recv_ra.txt");
return dec;
}


//encrypt data using other side's public key
string en_crypt(string str){

cout<<"\nR_b:"<<str;
std::ofstream file;
file.open("r_b.txt", std::ofstream::out | std::ofstream::trunc);
file << str;
file.close();
char c[SOCBUFSIZE];
//cout<<"\nabout to encrypt..";
strcpy(c,"openssl rsautl -encrypt -inkey clipubkey.pem -pubin -in r_b.txt -out r_b.enc"); //encrypt Random byte generated by Bob using Alice's public key
system(c);

//cout<<"\nEncrypted R_a using Bob's public key";
string enc=getkey("r_b.enc");
return enc;
}

int main(int argc, char *argv[])    {

int sockfd,newfd,port_num;
char sendbuf[SOCBUFSIZE],recbuf[SOCBUFSIZE];
struct sockaddr_in myaddr,thieraddr;
int numbytes;
string sendstr;
unsigned int sin_size;
unsigned char nonce[8];
char c1[2000],c2[2000],c3[2000],c4[2000],c5[2000];
char de[]="/////";
std::vector<char> recbuffer(SOCBUFSIZE);

strcpy(c5,"openssl rsa -in clikey.pem -pubout -out clipubkey.pem"); //get Alice's public key to encrypt Random byte generated by Bob
system(c5);

strcpy( c1, "openssl x509 -in clicert.crt -pubkey -noout > clipubkey.txt");  //get public key of Alice
system(c1);

strcpy( c2, "openssl x509 -in sercert.crt -pubkey -noout > serpubkey.txt");   //get public key of Bob
system(c2);

strcpy( c3, "cat serkey.pem >serprikey1.txt");  //get private key of Bob
system(c3);


string clipubkey = getkey("clipubkey.txt");	//get public key of Alice
string serpubkey = getkey("serpubkey.txt");	//get public key of Bob
string serprikey= getkey("serprikey1.txt"); //get private key of Bob

port_num=atoi(argv[1]);
cout<<"\nEntered port number:"<<port_num;
cin.clear();
fflush(stdin);

sockfd=socket(AF_INET,SOCK_STREAM,0);

myaddr.sin_family=AF_INET;
myaddr.sin_port=htons(port_num);
myaddr.sin_addr.s_addr=INADDR_ANY;

memset(&myaddr.sin_zero,'\0',8);

if( bind(sockfd,(struct sockaddr *)&myaddr,sizeof(struct sockaddr )) < 0){cout<<"\nBinding error..\n";}
else cout<<"\nBinding successful..\n";
listen(sockfd,5);

sin_size=sizeof(struct sockaddr_in);

newfd=accept(sockfd,(struct sockaddr *)&thieraddr,&sin_size);
if(newfd < 0) cout<<"Error accepting connection..\n";
else cout<<"\nConnection accepted\n";


cout<<"\n-------------------------------------------------------------";

numbytes=recv(newfd,recbuffer.data(),SOCBUFSIZE,0);
string firstmsg="";
//cout<<"\n1stmsg:"<<firstmsg;
//cout<<"\nrecv firstmsg.length():"<<firstmsg.length();
cout<<"\n1.Received bytes="<<numbytes;
//cout<<"\nrecbuffer:";
int i;
//for(i=0;i<numbytes;i++){
//cout<<recbuffer[i];
//}
i=0;
for(;i<numbytes;i++){
firstmsg.push_back(recbuffer[i]);
}
firstmsg[i]='\0';
//cout<<"\n1stmsg:"<<firstmsg;
//cout<<"\nrecv firstmsg.length():"<<firstmsg.length();



/*//I want to talk
//choose cipher	
//R_a(encrypted)
*/
string str1=tokenizer(recbuffer,de);
//cout<<"\nstr1:"<<str1;
string str2=tokenizer(recbuffer,de);
//cout<<"\nstr2:"<<str2;
string str3=tokenizer(recbuffer,de);
//cout<<"\nstr3:"<<str3;
//cout<<"\nenc_ra_len:"<<str3.length();

string r_a=de_crypt(str3); 							//decrypt R_a from Alice using Bob's private key
cout<<"\nReceived R_a after decryption:"<<r_a;

strcpy(c4,"openssl verify -CAfile ca.crt clicert.crt");		//verify Alice's certificate
system(c4);
cout<<"\n-------------------------------------------------------------";

//64 bits of random nonce
nonce[0]='\0';
RAND_bytes(nonce,sizeof(nonce));                                       //random nonce
//cout<<"\nrand nonce:"<<nonce;
nonce[sizeof(nonce)-1]='\0';
string rb_str((char *)nonce);
cout<<"\nnonce_str:"<<rb_str;
//cout<<"\nnonce_str.len:"<<rb_str.length();
string rb_enc= en_crypt(rb_str);      					  //encrypt nonce using public key
//cout <<"\nEncrpted R_a:"<<ra_enc;
//cout<<"\nrb_enc_len:"<<rb_enc.length();


string secmsg=str2+"/////"+rb_enc;
//cout<<"\nsecmsglen:"<<secmsg.length();
int sentbytes=send(newfd, secmsg.c_str(), secmsg.length(),0);		//send 2nd msg of SSL protocol
cout<<"\n2.sentbytes:"<<sentbytes;
if (sentbytes==-1)
  cout<<"\nCouldn't send ACK.";
cout<<"\n-------------------------------------------------------------";

recbuffer.clear();
recbuffer.resize(SOCBUFSIZE);
numbytes=recv(newfd,recbuffer.data(),SOCBUFSIZE,0);				//receive 3rd msg of SSL protocol
string thirdmsg="";
cout<<"\n3.Received bytes:"<<numbytes;
//for(i=0;i<numbytes;i++){
//cout<<recbuffer[i];
//}
i=0;
for(;i<numbytes;i++){
thirdmsg.push_back(recbuffer[i]);
}
thirdmsg[i]='\0';
//cout<<"\n3rdmsg:"<<thirdmsg;
//cout<<"\nrecv thirdmsg.length():"<<thirdmsg.length();


//cout<<"\nparsing mastersec..";
//mastersec
string str4=tokenizer(recbuffer,de);
//cout<<"\nstr4:"<<str4;
//cout<<"\nparsing hash..";
//keyed hash from Alice 
string str5=tokenizer(recbuffer,de);
cout<<"\nReceived hash:"<<str5;          
//cout<<"\nenc_ms_len:"<<str4.length();

string ms=de_crypt(str4);             				 //decrypt ms from Alice using Bob's private key
cout<<"\nReceived mastersec after decryption:"<<ms;

string sentnrec=firstmsg+secmsg+"server";
//cout<<"\nsentnrec len:"<<sentnrec.length();
unsigned char bob_haship [2000];
unsigned char bob_hashop [2000];
memcpy(bob_haship,sentnrec.c_str(),sentnrec.length());
SHA1(bob_haship,sentnrec.length(),bob_hashop);
cout<<"\nbob_hash:"<<bob_hashop;					//compute Bob's hash
cout<<"\nbob_hash_len:"<<strlen((char *)bob_hashop);

string sentnrec_bob=firstmsg+secmsg+"client";
//cout<<"\nsentnrec len:"<<sentnrec_bob.length();
unsigned char alice_haship [2000];
unsigned char alice_hashop [2000];
memcpy(alice_haship,sentnrec_bob.c_str(),sentnrec_bob.length());
SHA1(alice_haship,sentnrec_bob.length(),alice_hashop);
cout<<"\ncomputed alice_hash:"<<alice_hashop;
cout<<"\ncomputed alice_hash_len:"<<strlen((char *)alice_hashop);
string alice_hashop_str((char *) alice_hashop);

//cout<<"\nstr5:"<<str5;
//cout<<"\ncalc alice hash:"<<alice_hashop_str;
cout<<"\nstrcmp_hash:"<<strcmp(str5.c_str(),alice_hashop_str.c_str());
int match=1;
if(strcmp(str5.c_str(),alice_hashop_str.c_str())==0){				//check if hash matches
cout<<"\nhash matches...";

}
else{
match=0;
cout<<"\nHash did not match...";
}
cout<<"\n-------------------------------------------------------------";
if(match==1)
{
string bob_hashop_str((char *) bob_hashop);
sentbytes=send(newfd, bob_hashop_str.c_str(), bob_hashop_str.length(),0);			//send keyed hash of Bob
cout<<"\n4.sentbytes:"<<sentbytes;
if (sentbytes==-1)
  cout<<"\nCouldn't send ACK.";
cout<<"\n-------------------------------------------------------------";


//cout<<"\nms:"<<ms;
//cout<<"\nms_len:"<<ms.length();
if(ms.length()>7) ms[7]='\0';
//cout<<"\nmastersecs:"<<ms;
string enc_str=ms+"enc";  															//generate encryption key as a func of mastersec with parameter="enc"
//cout<<"\nenc_str:"<<enc_str;
string tempms=getkey("r_a.txt");
//cout<<"\ntempms:"<<tempms;
//cout<<"\nstrcmp(ms,tempms):"<<strcmp(ms.c_str(),tempms.c_str());
unsigned char bob_enc[2000];
unsigned char symm_enc_key[2000];
memcpy(bob_enc,enc_str.c_str(),enc_str.length());
SHA1(bob_enc,enc_str.length(),symm_enc_key);										//compute symmetric key from SHA1
cout<<"\nsymm_enc_key:"<<symm_enc_key;
cout<<"\nsymmkey_len:"<<strlen((char *)symm_enc_key);



string auth_str=ms+"auth";											//generate authentication key as a func of mastersec with parameter="auth"
unsigned char bob_auth[2000];
unsigned char symm_auth_key[2000];
memcpy(bob_auth,auth_str.c_str(),auth_str.length());
SHA1(bob_auth,auth_str.length(),symm_auth_key);						//compute auth key from SHA1
cout<<"\nsymm_auth_key:"<<symm_auth_key;
cout<<"\nsymm_auth_len:"<<strlen((char *)symm_auth_key);
cout<<"\n-------------------------------------------------------------";


/*record header
Byte   0       = SSL record type
Bytes 1-2      = SSL version (major/minor)
Bytes 3-4      = Length of data in the record (excluding the header itself).
*/
string rh="data,myssl,50000";			
cout<<"\nrecord header:"<<rh;						
string data="";
std::vector<char> v(50000);
std::generate(v.begin(), v.end(), RandomNumber);
cout<<"\n-----------generating random data---------";
for(i=0;i<50000;i++){
//cout<<i<<" ";
data.push_back(v[i]);
}
cout<<"\n-----random data generated---------------";
data[i]='\0';
//cout<<"\nvec len:"<<v.size();
//cout<<"\ndata len:"<<data.length();

string rec_str=rh+data;
unsigned char record[50000];
unsigned char record_hash[50000];
memcpy(record,rec_str.c_str(),rec_str.length());
SHA1(record,rec_str.length(),record_hash);
cout<<"\nrecord_hash:"<<record_hash;
cout<<"\nrecord_hash_len:"<<strlen((char *)record_hash);
string record_hash_str((char *) record_hash);

string datanhash=data+"/////"+record_hash_str;
cout<<"\ndatanhash len:"<<datanhash.length();

ofstream tempfile;
tempfile.open ("tempfile.txt", std::ofstream::out | std::ofstream::trunc);			//store the data and hash(rh+data) in a file
tempfile << datanhash;
tempfile.close();
cout<<"\n-------------------------------------------------------------";

int num = 0;
std::stringstream is, hs;
is << symm_enc_key; 
is >> num; // convert string to int
hs << std::hex << num; // push int through hex manipulator
string hex_symm_key= hs.str(); // store hex string

string iv="qwerty123456789asdfg";
num = 0;
std::stringstream is2, hs2;
is2 << iv;
is2 >> num; // convert string to int
hs2 << std::hex << num; // push int through hex manipulator
string hex_iv= hs2.str(); // store hex string

char c8[2000];
string temp="openssl enc -AES-128-CBC -K "+hex_symm_key+" -iv "+hex_iv+" -in tempfile.txt -out enc_tempfile.txt";		//encrypt the data using AES and stroe in file
strcpy(c8,temp.c_str());
system(c8);

string enc_data=getkey("enc_tempfile.txt");
cout<<"\nenc_data.len:"<<enc_data.length();
cout<<"\n-------------------------------------------------------------";

string final_record=rh+"/////"+enc_data;
cout<<"\nfinal_record len:"<<final_record.length();			

ofstream final_file;
final_file.open ("final_file.txt", std::ofstream::out | std::ofstream::trunc);
final_file << final_record;
final_file.close();

cout<<"\nreading final file..";
FILE *fs = fopen("final_file.txt", "r");
if(fs == NULL)
{
  cout<<"\nFile not found..";
  exit(1);
}
vector<char> readbuffer(50200); 
int BUFSZ=50200;
int fs_block_sz;
while((fs_block_sz = fread(readbuffer.data(), sizeof(char),50200, fs)) > 0)					//send the file of 50kB
{
  cout<<"\nbytes read:"<<fs_block_sz;
  sentbytes=send(newfd, readbuffer.data(), fs_block_sz,0);
  cout<<"\nsentbytes:"<<sentbytes;
  if (sentbytes==-1)
    cout<<"\nCouldn't send file";
  readbuffer.clear();
  readbuffer.resize(SOCBUFSIZE);
}
}
cout<<"\n-------------------------------------------------------------\n";
//while(1){
//
//numbytes=recv(newfd,recbuf,999,0);
//recbuf[numbytes+1]='\0';
//cout<<"\nClient: "<<recbuf<<"\n";
//recbuf[0]='\0';
//cout<<"\nServer:";
//getline(cin,sendstr);
//strncpy(sendbuf,sendstr.c_str(),sizeof(sendbuf));
//sendbuf[sizeof(sendbuf)-1]=0;
//if(send(newfd,sendbuf,strlen(sendbuf)+1,0)==1)   {
//       cout<<"\nsend error\n";
//       exit(1);
//       }
//sendbuf[0]='\0';
//}
close(newfd);
close(sockfd);

return 0;
}

