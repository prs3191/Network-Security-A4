#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<pthread.h>
#include<arpa/inet.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<iostream>
#include<stdlib.h>
#include<sstream>
#include<openssl/rand.h>
#include<openssl/des.h>
#include<fstream>
#include<vector>
#include<openssl/sha.h>
#include<algorithm>

#define BUFSIZE 512
#define SOCBUFSIZE 8000
using namespace std;
static int idx=0;
static vector<char> globinp;

//parser
string tokenizer(vector<char> input, char * delimiter){
//cout<<"\ninput sz:"<<input.size();
//for (std::vector<char>::const_iterator i = input.begin(); i != input.end(); ++i)
  //  std::cout << *i;
int delimcount=0;
string temp="";
//cout<<"\ngbinp sz:"<<globinp.size();
if(globinp.empty()){
//cout<<"\nin parsing..assign global string..";
 globinp.swap(input);
// cout<<"\ngbinp sz:"<<globinp.size();
}
for(;idx<globinp.size();idx++){
if(globinp[idx]=='/'){
for(;idx<globinp.size() && delimcount<5;){		//skip the delimiter
   if(globinp[idx]=='/'){
    delimcount++;
    idx++;
   }
   else break;
}
}
if(delimcount<5){
  if(delimcount>0){
    idx=idx-delimcount;
    for(;delimcount>0;delimcount--){
       temp.push_back(globinp[idx]);
       idx++;									//if delimiter is not found, rewind
    }
    idx--;
  }
  else{
    temp.push_back(globinp[idx]);
    //cout<<"\ntemp:"<<temp;
  }
}
else{
//idx--;
//cout<<"\nidx="<<idx;
return temp;									//part of the input is found
}
}
if(idx==globinp.size()){
idx=0;
globinp.clear();
return temp;
}
}


//read the contents from file
string getkey(string filename){
	
std::ifstream file(filename.c_str());
std::string str;
std::string file_contents;
while (std::getline(file, str))
{
  file_contents += str;
  if(!file.eof())
    file_contents.push_back('\n');
} 
file.close(); 
return file_contents;
}

//encrypt data using other side's public key
string en_crypt(string str){

//cout<<"\nto encrypt:"<<str;
std::ofstream file;
file.open("r_a.txt", std::ofstream::out | std::ofstream::trunc);
file << str;
file.close();
char c[SOCBUFSIZE];
//cout<<"\nabout to encrypt..";
strcpy(c,"openssl rsautl -encrypt -inkey serpubkey.pem -pubin -in r_a.txt -out r_a.enc"); 	//encrypt Random byte generated by Alice using Bob's public key
system(c);

//cout<<"\nEncrypted str using Bob's public key";
string enc=getkey("r_a.enc");
return enc;

}

//decrypt using the private key generated from public key,private key pair
string de_crypt(string str){
std::ofstream file;
file.open("encrypted_rb.enc");
file << str;
file.close();
char c[8000];
strcpy(c,"openssl rsautl -decrypt -inkey clikey.pem -in r_b.enc -out recv_rb.txt"); //decrypt by Alice private key
system(c);

//cout<<"\n Decrypted R_b using Alice's private key";
string dec=getkey("recv_rb.txt");
return dec;
}



int main(int argc, char *argv[])    {


int sockfd,numbytes,port_num;
struct sockaddr_in thieraddr;
char sendbuf[SOCBUFSIZE],recbuf[SOCBUFSIZE];
unsigned char nonce[8];
char c1[2000],c2[2000],c3[2000],c4[2000],c5[2000];
string sendstr;
std::vector<char> recbuffer(SOCBUFSIZE);
char de[]="/////";

strcpy(c5,"openssl rsa -in serkey.pem -pubout -out serpubkey.pem"); //get Bob's public key to encrypt Random byte generated by Alice
system(c5);

strcpy( c1, "openssl x509 -in clicert.crt -pubkey -noout > clipubkey.txt"); //get public key of Alice
system(c1);

strcpy( c2, "openssl x509 -in sercert.crt -pubkey -noout > serpubkey.txt"); //get public key of Bob
system(c2);


strcpy( c3, "cat clikey.pem >cliprikey1.txt");
system(c3);

string clipubkey = getkey("clipubkey.txt");	//get public key of Alice
string serpubkey = getkey("serpubkey.txt");	//get public key of Bob
string cliprikey = getkey("cliprikey1.txt");	//get private key of Alice


sockfd=socket(AF_INET,SOCK_STREAM,0);

port_num=atoi(argv[1]);
cout<<"\nEntered port number:"<<port_num;
cin.clear();fflush(stdin);

thieraddr.sin_family=AF_INET;
thieraddr.sin_port=htons(port_num);
thieraddr.sin_addr.s_addr=INADDR_ANY;

memset(&thieraddr.sin_zero,'\0',8);

if( connect(sockfd,(struct sockaddr *)&thieraddr,sizeof(struct sockaddr)) < 0)
  cout <<"\nConnect error\n";

cout<<"\n-------------------------------------------------------------";
//64 bits of random nonce
nonce[0]='\0';
RAND_bytes(nonce,sizeof(nonce));										//random nonce
//cout<<"\nrand nonce:"<<nonce;
nonce[sizeof(nonce)-1]='\0';
string ra_str((char *)nonce);
cout<<"\nnonce_str:"<<ra_str;
//cout<<"\nnonce_str.len:"<<ra_str.length();
string ra_enc= en_crypt(ra_str);	//encrypt nonce using public key
//cout <<"\nEncrpted R_a:"<<ra_enc;
//cout<<"\nra_enc_len:"<<ra_enc.length();

//send 1st msg of SSL protocol
string hi_msg="I want to talk";
string chosen_cipher="AES,SHA1";
string firstmsg=hi_msg+"/////"+chosen_cipher+"/////"+ra_enc;
//cout<<"\n1stmsg:"<<firstmsg;
//cout<<"\nfirstmsg.length:"<<firstmsg.length();
bzero(sendbuf,sizeof(sendbuf));
sendbuf[0]='\0';
int i=0;
int j=-1;
for(;i<firstmsg.length();i++){
sendbuf[i]=firstmsg[i];
if(sendbuf[i]=='\0') j=i;
}
//cout<<"\ni:"<<i;
sendbuf[i]='\0';
//cout<<"\nj="<<j;
//cout<<"\nsendbuf_len:"<<strlen(sendbuf);

int sentbytes=send(sockfd, sendbuf,i,0);
cout<<"\n1.sentbytes:"<<sentbytes;
if(sentbytes==-1)
	cout<<"Couldn't send ACK.";
cout<<"\n-------------------------------------------------------------";

//receive second message of SSL protocol
numbytes=recv(sockfd,recbuffer.data(),SOCBUFSIZE,0);
string secmsg="";
cout<<"\nReceived bytes="<<numbytes;

//for(i=0;i<numbytes;i++){
//cout<<recbuffer[i];
//}
i=0;
for(;i<numbytes;i++){
secmsg.push_back(recbuffer[i]);
}
secmsg[i]='\0';
//cout<<"\n2ndmsg:"<<secmsg;
//cout<<"\nrecv secmsg.length():"<<secmsg.length();

 //chosen method
string str1=tokenizer(recbuffer,de);
//R_b(encrypted)
string str2=tokenizer(recbuffer,de);          

//cout<<"\nenc_rb_len:"<<str2.length();

string r_b=de_crypt(str2);              //decrypt R_b from Bob  using Alice's private key
cout<<"\nReceived R_a after decryption:"<<r_b;

strcpy(c4,"openssl verify -CAfile ca.crt sercert.crt");		//verify the server certificate using CA
system(c4);
cout<<"\n-------------------------------------------------------------";
//cout<<"\nra:"<<ra_str;
//cout<<"\nrb:"<<r_b;
//r_b[0]='x';																//-------to demo failed verification of keyed hash---------
string mastersec=ra_str;
for(i=0;i<7;i++){
mastersec[i] = ra_str[i] ^ r_b[i];
}
mastersec[i]='\0';
cout<<"\nmastersec:"<<mastersec;
//cout<<"\nmastersec_len:"<<mastersec.length();
string ms_enc=en_crypt(mastersec);
string tempms=getkey("r_a.txt");
//cout<<"\nms written in file:"<<tempms;
//cout<<"\ntempms_len:"<<tempms.length();


string sentnrec=firstmsg+secmsg+"client";
//string sentnrec=firstmsg+secmsg+"cli";						//-------to demo failed verification of keyed hash---------
//cout<<"\nsentnrec len:"<<sentnrec.length();
unsigned char alice_haship [2000];
unsigned char alice_hashop [2000];
memcpy(alice_haship,sentnrec.c_str(),sentnrec.length());
SHA1(alice_haship,sentnrec.length(),alice_hashop);				//SHA1 to find hash of all messages sent and received so far
cout<<"\nalice_hash:"<<alice_hashop;
cout<<"\nalice_hash_len:"<<strlen((char *)alice_hashop);
string alice_hashop_str((char *) alice_hashop);

string thirdmsg=ms_enc+"/////"+alice_hashop_str;
//cout<<"\nthirdmsg len:"<<thirdmsg.length();
sentbytes=send(sockfd, thirdmsg.c_str(),thirdmsg.length(),0);		//send the master secret encrypted by bob's public key and computed hash
cout<<"\nsentbytes:"<<sentbytes;
if(sentbytes==-1)
        cout<<"Couldn't send ACK.";
cout<<"\n-------------------------------------------------------------";

recbuffer.clear();
recbuffer.resize(SOCBUFSIZE);
numbytes=recv(sockfd,recbuffer.data(),SOCBUFSIZE,0);				//receive hash from Bob
string fourthmsg="";
cout<<"\nReceived bytes="<<numbytes;

//for(i=0;i<numbytes;i++){
//cout<<recbuffer[i];
//}
i=0;
for(;i<numbytes;i++){
fourthmsg.push_back(recbuffer[i]);
}
fourthmsg[i]='\0';
//cout<<"\n4thmsg:"<<fourthmsg;
//cout<<"\nrecv fourthmsg.length():"<<fourthmsg.length();

string sentnrec_ser=firstmsg+secmsg+"server";					//to compute Bob's hash
unsigned char bob_haship [2000];
unsigned char bob_hashop [2000];
memcpy(bob_haship,sentnrec_ser.c_str(),sentnrec_ser.length());
SHA1(bob_haship,sentnrec_ser.length(),bob_hashop);				//compute Bob's hash
cout<<"\ncomputed bob_hash:"<<bob_hashop;
cout<<"\ncomputed bob_hash_len:"<<strlen((char *)bob_hashop);
string bob_hashop_str((char *) bob_hashop);

if(fourthmsg == bob_hashop_str){
cout<<"\nhash matches...";
}
else{
	cout<<"\nkeyed hash did not match...so following keys generated from mastersec won't match either";
}
cout<<"\n-------------------------------------------------------------";

string enc_str=mastersec+"enc";										//generate encryption key as a func of mastersec with parameter="enc"
cout<<"\nenc_str:"<<enc_str;
unsigned char alice_enc[2000];
unsigned char symm_enc_key[2000];
memcpy(alice_enc,enc_str.c_str(),enc_str.length());
SHA1(alice_enc,enc_str.length(),symm_enc_key);
cout<<"\nsymm_enc_key:"<<symm_enc_key;								//compute symmetric key from SHA1
cout<<"\nsymmkey_len:"<<strlen((char *)symm_enc_key);


string auth_str=mastersec+"auth";								   //generate authentication key as a func of mastersec with parameter="auth"
cout<<"\nauth_str:"<<auth_str;
unsigned char alice_auth[2000];
unsigned char symm_auth_key[2000];
memcpy(alice_auth,auth_str.c_str(),auth_str.length());
SHA1(alice_auth,auth_str.length(),symm_auth_key);					//compute auth key from SHA1
cout<<"\nsymm_auth_key:"<<symm_auth_key;
cout<<"\nsymmkey_len:"<<strlen((char *)symm_auth_key);

cout<<"\n-------------------------------------------------------------";

int BUFSZ=50200;
recbuffer.clear();
recbuffer.resize(BUFSZ);
vector<char> recbuffer2;
int total_recbytes;
FILE *fr = fopen("recv_final_file.txt", "w+");					//store the data
if(fr == NULL)
   cout<<"\nfile not found";
else
{
i=0;
cout<<"\nreceive 50KB of data in a file..";
while((numbytes=recv(sockfd,recbuffer.data(),BUFSZ,0))>0)		//receive 50KB of data in a file
{
  cout<<"\nReceived bytes="<<numbytes;
  total_recbytes += numbytes;
  i=0;
  for(;i<numbytes;i++){
     recbuffer2.push_back(recbuffer[i]);
  }
  cout<<"\nrecbuffer2 sz="<<recbuffer2.size();
  recbuffer.clear();
  recbuffer.resize(BUFSZ);

  }
}
cout<<"\ntotal bytes recv:"<<total_recbytes;
cout<<"\nrecbuffer2.size()="<<recbuffer2.size();
int write_sz = fwrite(recbuffer2.data(), sizeof(char), total_recbytes, fr);
if(write_sz==total_recbytes)
  cout<<"\nfile written in client";
fclose(fr);

cout<<"\n-------------------------------------------------------------";

string rh=tokenizer(recbuffer2,de);
cout<<"\nrh:"<<rh;
string enc_datanhash=tokenizer(recbuffer2,de);
cout<<"\nenc_datanhash len:"<<enc_datanhash.length();

int num = 0;
std::stringstream is, hs;
is << symm_enc_key;
is >> num; // convert string to int
hs << std::hex << num; // push int through hex manipulator
string hex_symm_key= hs.str(); // store hex string

string iv="qwerty123456789asdfg";					//IV for AES
num = 0;
std::stringstream is2, hs2;
is2 << iv;
is2 >> num; // convert string to int
hs2 << std::hex << num; // push int through hex manipulator
string hex_iv= hs2.str(); // store hex string

ofstream tempfile;
tempfile.open ("datanhash.txt", std::ofstream::out | std::ofstream::trunc);			//write encrypted data and hash recived from Bob
tempfile << enc_datanhash;
tempfile.close();
cout<<"\n-------------------------------------------------------------";

char c8[2000];
string temp="openssl enc -AES-128-CBC -d -K "+hex_symm_key+" -iv "+hex_iv+" -in datanhash.txt -out dec_final_file.txt";		//decrypt using AES, key is symmetric key generated from mastersec
strcpy(c8,temp.c_str());
system(c8);

string datanhash=getkey("dec_final_file.txt");			//get the actual contents of data and hash of data after decryption
cout<<"\ndatanhash len:"<<datanhash.length();
i=0;
recbuffer.clear();
recbuffer.resize(0);

for(;i<datanhash.length();i++){
recbuffer.push_back(datanhash[i]);
}
//cout<<"\nrecbuffer sz="<<recbuffer.size();
cout<<"\n-------------------------------------------------------------";

string data=tokenizer(recbuffer,de);				//split data and hash of data	
cout<<"\ndata len:"<<data.length();
string recv_record_hash=tokenizer(recbuffer,de);
cout<<"\nrecv_record_hash len="<<recv_record_hash.length();


string rec_str=rh+data;								//compute the hash of record header and data 
unsigned char record[50000];
unsigned char record_hash[50000];
memcpy(record,rec_str.c_str(),rec_str.length());
SHA1(record,rec_str.length(),record_hash);
cout<<"\nrecord_hash:"<<record_hash;
cout<<"\nrecord_hash_len:"<<strlen((char *)record_hash);
string record_hash_str((char *) record_hash);


int cmp=strcmp(recv_record_hash.c_str(),record_hash_str.c_str());
cout<<"\ncmp:"<<cmp;
if(cmp==0)
  cout<<"\nhash of rh+data matches..";

cout<<"\n-------------------------------------------------------------\n";
cout<<"\ndiff dec_final_file.txt tempfile.txt\n";

//while(1){
//        cout<<"\nClient: ";
//        cin.clear();fflush(stdin);
//        getline(cin,sendstr);
//        strncpy(sendbuf,sendstr.c_str(),sizeof(sendbuf));
//        sendbuf[sizeof(sendbuf)-1]='\0';
//
//        if(send(sockfd,sendbuf,strlen(sendbuf)+1,0)==1)
//                cout<<"\nSend error\n";
//
//        numbytes=recv(sockfd,recbuf,999,0);
//
//        recbuf[numbytes+1]='\0';
//
//        cout<<"\nServer: "<<recbuf<<"\n";
//        recbuf[0]='\0';
//}
        close(sockfd);
return 0;

}

